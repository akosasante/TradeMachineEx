#!/bin/sh

# Container-friendly release configuration for TradeMachine Ex

# Disable heart in containerized environments
# Containers have their own restart mechanisms
case $RELEASE_COMMAND in
  daemon*)
    if [ "$CONTAINER_MODE" = "true" ]; then
      # In container mode, don't use heart
      echo "Container mode: disabling heart monitoring"
    else
      # Traditional daemon mode with heart
      HEART_COMMAND="$RELEASE_ROOT/bin/$RELEASE_NAME $RELEASE_COMMAND"
      export HEART_COMMAND
      export ELIXIR_ERL_OPTIONS="-heart"
    fi
    ;;
  start*)
    # Container mode: use start instead of daemon for proper signal handling
    echo "Starting in container-friendly mode"
    ;;
  *)
    ;;
esac

# Node configuration for containers
if [ "$CONTAINER_MODE" = "true" ]; then
  # In containers, use a simpler node configuration
  export RELEASE_DISTRIBUTION=none
else
  # Traditional deployment with clustering support
  export RELEASE_DISTRIBUTION=sname
  export RELEASE_NODE=<%= @release.name %>@${HOSTNAME:-localhost}
fi

# Cookie configuration
export RELEASE_COOKIE=${RELEASE_COOKIE:-TEST_COOKIE}

# Container-optimized ERL options
if [ "$CONTAINER_MODE" = "true" ]; then
  # Optimize for containers: better memory reporting, async threads
  export ELIXIR_ERL_OPTIONS="+sbwt none +sbwtdcpu none +sbwtdio none +swt low +stbt db +sssdcpu 16 +sssdio 16"
else
  # Traditional deployment settings
  export ELIXIR_ERL_OPTIONS="-proto_dist inet6_tcp"
fi

# Set memory allocation strategy for containers
if [ -n "$ERL_MAX_PORTS" ]; then
  export ERL_MAX_PORTS=$ERL_MAX_PORTS
fi

if [ -n "$ERL_MAX_ETS_TABLES" ]; then
  export ERL_MAX_ETS_TABLES=$ERL_MAX_ETS_TABLES
fi

# Enable crash dumps in a container-friendly location
export ERL_CRASH_DUMP=/tmp/erl_crash.dump

# Set up logging for containers (output to stdout/stderr)
if [ "$CONTAINER_MODE" = "true" ]; then
  # Ensure logs go to stdout for proper container log collection
  export RELEASE_SYS_CONFIG=""
fi
